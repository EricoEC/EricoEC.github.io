<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>动态线条背景</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
"use strict";
var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    }();
}();
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); }
}

// 初始化画布
var c = document.getElementById('c');
var w = c.width = window.innerWidth;
var h = c.height = window.innerHeight;
var ctx = c.getContext('2d');
var tick = 0;
Math.TAU = 6.28318530717958647692; // 2π常量
var vertices = [];

// 动画配置参数（可自定义调整效果）
var opts = {
    hexLength: 30,          // 顶点间距（越小线条越密）
    timeStep: .01,          // 动画速度（越大越快）
    randomJig: 8,           // 线条抖动幅度
    repaintColor: 'rgba(0,0,0,.1)', // 拖影效果（透明度越小拖影越长）
    lenFn: function (_ref) {
        var len = _ref.len; var t = _ref.t;
        return len + Math.sin(t);
    },
    radFn: function (_ref2) {
        var rad = _ref2.rad; var len = _ref2.len; var t = _ref2.t; var excitement = _ref2.excitement;
        return rad + (excitement + opts.propFn({ len: len, t: t })) * 2 / 4;
    },
    propFn: function (_ref3) {
        var len = _ref3.len; var t = _ref3.t;
        return len / opts.hexLength / 10 - t;
    },
    excitementFn: function (_ref4) {
        var len = _ref4.len; var t = _ref4.t;
        return Math.sin(opts.propFn({ len: len, t: t })) ** 2;
    },
    colorFn: function (_ref5) {
        var rad = _ref5.rad; var excitement = _ref5.excitement; var t = _ref5.t;
        return 'hsl(' + (rad / Math.TAU * 360 + t) + ', ' + excitement * 100 + '%, ' + (20 + excitement * 50) + '%)';
    }
};

// 顶点类（控制单个顶点的位置更新和绘制）
var Vertex = function () {
    function Vertex(_ref6) {
        var x = _ref6.x; var y = _ref6.y;
        _classCallCheck(this, Vertex);
        this.len = Math.sqrt(x * x + y * y);
        this.rad = Math.acos(x / this.len) * (y > 0 ? 1 : -1) + .13;
        this.prevPoint = { x: x, y: y };
    }
    _createClass(Vertex, [{
        key: 'step',
        value: function step() {
            var excitement = opts.excitementFn({ len: this.len, t: tick });
            var param = { len: this.len, rad: this.rad, t: tick, excitement: excitement };
            var nextLen = opts.lenFn(param);
            var nextRad = opts.radFn(param);
            var color = opts.colorFn(param);

            // 绘制线条
            ctx.strokeStyle = color;
            ctx.lineWidth = excitement + .2;
            ctx.beginPath();
            ctx.moveTo(this.prevPoint.x, this.prevPoint.y);
            this.prevPoint.x = nextLen * Math.cos(nextRad) + Math.random() * (1 - excitement) ** 2 * opts.randomJig * 2 - opts.randomJig;
            this.prevPoint.y = nextLen * Math.sin(nextRad) + Math.random() * (1 - excitement) ** 2 * opts.randomJig * 2 - opts.randomJig;
            ctx.lineTo(this.prevPoint.x, this.prevPoint.y);
            ctx.stroke();
        }
    }], [{
        key: 'gen',
        value: function gen() {
            vertices.length = 0;
            var hexCos = Math.cos(Math.TAU / 12) * opts.hexLength;
            var hexSin = Math.sin(Math.TAU / 12) * opts.hexLength;
            var alternanceX = false;
            for (var x = 0; x < w; x += hexCos) {
                var alternance = alternanceX = !alternanceX;
                for (var y = 0; y < h; y += hexSin + opts.hexLength) {
                    alternance = !alternance;
                    vertices.push(new Vertex({
                        x: x - w / 2,
                        y: y + alternance * hexSin - h / 2
                    }));
                }
            }
        }
    }]);
    return Vertex;
}();

// 生成顶点网格 + 初始画布填充
Vertex.gen();
ctx.fillStyle = '#222';
ctx.fillRect(0, 0, w, h);

// 动画循环
var anim = function anim() {
    window.requestAnimationFrame(anim);
    tick += opts.timeStep;
    ctx.fillStyle = opts.repaintColor;
    ctx.fillRect(0, 0, w, h);
    ctx.translate(w / 2, h / 2);
    vertices.forEach(function (vertex) { return vertex.step(); });
    ctx.translate(-w / 2, -h / 2);
};
anim();

// 窗口 resize 适配
window.addEventListener('resize', function () {
    w = c.width = window.innerWidth;
    h = c.height = window.innerHeight;
    Vertex.gen();
    tick = 0;
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, w, h);
});
</script>
</body>
</html>
