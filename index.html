<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>动态线条背景（修复版）</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #222; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
// 简化版：移除复杂语法，兼容所有浏览器
const c = document.getElementById('c');
const ctx = c.getContext('2d');
let w = c.width = window.innerWidth;
let h = c.height = window.innerHeight;
let tick = 0;
const TAU = Math.PI * 2; // 替代自定义Math.TAU，避免兼容问题
const vertices = [];

// 简化配置参数，减少计算复杂度
const opts = {
    hexLength: 30,
    timeStep: 0.01,
    randomJig: 8,
    repaintColor: 'rgba(0,0,0,0.1)'
};

// 顶点类（用ES6简化语法）
class Vertex {
    constructor(x, y) {
        this.len = Math.sqrt(x * x + y * y);
        this.rad = Math.acos(x / this.len) * (y > 0 ? 1 : -1) + 0.13;
        this.prevX = x;
        this.prevY = y;
    }

    step() {
        // 简化计算逻辑，避免复杂函数嵌套
        const prop = this.len / opts.hexLength / 10 - tick;
        const excitement = Math.sin(prop) ** 2;
        const nextLen = this.len + Math.sin(tick);
        const nextRad = this.rad + (excitement + prop) * 0.5;
        
        // 颜色计算简化
        const hue = (nextRad / TAU * 360 + tick) % 360;
        const color = `hsl(${hue}, ${excitement * 100}%, ${20 + excitement * 50}%)`;

        // 绘制线条
        ctx.strokeStyle = color;
        ctx.lineWidth = excitement + 0.2;
        ctx.beginPath();
        ctx.moveTo(this.prevX, this.prevY);
        
        // 新位置计算
        this.prevX = nextLen * Math.cos(nextRad) + (Math.random() - 0.5) * opts.randomJig * (1 - excitement);
        this.prevY = nextLen * Math.sin(nextRad) + (Math.random() - 0.5) * opts.randomJig * (1 - excitement);
        
        ctx.lineTo(this.prevX, this.prevY);
        ctx.stroke();
    }

    // 生成顶点网格
    static gen() {
        vertices.length = 0;
        const hexCos = Math.cos(TAU / 12) * opts.hexLength;
        const hexSin = Math.sin(TAU / 12) * opts.hexLength;
        let alternanceX = false;

        for (let x = 0; x < w; x += hexCos) {
            alternanceX = !alternanceX;
            let alternance = alternanceX;
            for (let y = 0; y < h; y += hexSin + opts.hexLength) {
                alternance = !alternance;
                const vx = x - w / 2;
                const vy = y + (alternance ? hexSin : 0) - h / 2;
                vertices.push(new Vertex(vx, vy));
            }
        }
    }
}

// 初始化
Vertex.gen();
ctx.fillRect(0, 0, w, h);

// 动画循环
function anim() {
    requestAnimationFrame(anim);
    tick += opts.timeStep;

    // 清屏（保留拖影）
    ctx.fillStyle = opts.repaintColor;
    ctx.fillRect(0, 0, w, h);

    // 画布居中
    ctx.save();
    ctx.translate(w / 2, h / 2);
    vertices.forEach(v => v.step());
    ctx.restore();
}
anim();

// 窗口适配
window.addEventListener('resize', () => {
    w = c.width = window.innerWidth;
    h = c.height = window.innerHeight;
    Vertex.gen();
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, w, h);
});
</script>
</body>
</html>
