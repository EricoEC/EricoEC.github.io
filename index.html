<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>欢迎来到我的主页！</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        /* 动态线条背景：全屏底层固定 */
        #c { position: fixed; top: 0; left: 0; z-index: -1; }
        body { 
            font-family: "微软雅黑", sans-serif; 
            color: #fff; /* 所有文字全白 */
            min-height: 100vh;
            display: flex; /* 弹性布局居中 */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin: 0;
            cursor: default; /* 消除文本选中光标，不影响点击 */
            touch-action: none; /* 禁止浏览器默认触控行为（如缩放） */
        }
        /* 标题样式（可选，居中显示） */
        h1 { margin-bottom: 25px; font-size: 28px; text-shadow: 0 0 8px rgba(0,0,0,0.5); }
        /* 城市选择器：居中适配 */
        .city-select-wrap { margin-bottom: 20px; }
        label { font-size: 18px; margin-right: 10px; }
        select { 
            padding: 10px 8px; 
            border-radius: 6px; 
            border: none; 
            font-size: 16px;
            background: rgba(255,255,255,0.9);
            color: #333;
            cursor: pointer;
        }
        /* 天气预报模块：居中悬浮 + 半透黑背景 */
        #weather { 
            display: flex; 
            align-items: center; 
            gap: 20px; 
            padding: 25px; 
            border: 1px solid rgba(255,255,255,0.2); /* 淡白边框 */
            border-radius: 12px;
            background: rgba(0,0,0,0.6); /* 半透黑背景，不挡线条 */
            backdrop-filter: blur(8px); /* 毛玻璃增强质感 */
            max-width: 400px;
            width: 100%;
        }
        #weather img { width: 60px; height: 60px; }
        .weather-text { font-size: 18px; line-height: 1.8; }
        /* 版权信息：底部居中 */
        .copyright { 
            position: fixed; 
            bottom: 20px; 
            font-size: 14px; 
            color: rgba(255,255,255,0.7);
        }
        /* 缩小40%后的爱心样式（原16px→10px） */
        .heart {
            width: 10px;
            height: 10px;
            position: fixed;
            background: currentColor; /* 继承颜色 */
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
            -moz-transform: rotate(45deg);
            opacity: 1;
            z-index: 9999; /* 确保在最上层，不被遮挡 */
            pointer-events: none; /* 避免遮挡页面交互 */
        }
        .heart:before,
        .heart:after {
            content: '';
            width: 10px;
            height: 10px;
            background: inherit;
            border-radius: 50%;
            -webkit-border-radius: 50%;
            -moz-border-radius: 50%;
            position: absolute;
        }
        .heart:before {
            top: -5px; /* 偏移量为尺寸的一半 */
            left: 0;
        }
        .heart:after {
            top: 0;
            left: -5px; /* 偏移量为尺寸的一半 */
        }
        /* 五角星样式（增大一倍，20px→缩放后10px，与爱心等大） */
        .star {
            width: 20px;
            height: 20px;
            position: fixed;
            color: currentColor; /* 继承颜色 */
            opacity: 1;
            z-index: 9999;
            pointer-events: none;
            clip-path: polygon(
                50% 0%, 
                61% 35%, 
                98% 35%, 
                68% 57%, 
                79% 91%, 
                50% 70%, 
                21% 91%, 
                32% 57%, 
                2% 35%, 
                39% 35%
            );
            background: currentColor;
            transform: scale(0.5);
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <h1>实时天气预报</h1>

    <!-- 城市选择 -->
    <div class="city-select-wrap">
        <label for="city-select">选择城市：</label>
        <select id="city-select">
            <option value="101010100">北京</option>
            <option value="101020100">上海</option>
            <option value="101280101">广州</option>
            <option value="101210101">武汉</option>
            <option value="101030100">天津</option>
            <option value="101190101">香港</option>
            <option value="101140101">西安</option>
            <option value="101040100">重庆</option>
            <option value="101230101">杭州</option>
            <option value="101250101">成都</option>
        </select>
    </div>

    <!-- 天气模块 -->
    <div id="weather">
        <img id="weather-icon" src="" alt="天气图标">
        <div class="weather-text">
            <p id="weather-city">城市: 加载中...</p>
            <p id="weather-info">天气: 加载中...</p>
            <p id="weather-temp">温度: 加载中...</p>
        </div>
    </div>

    <div class="copyright">Copyright © 2025 晓楠瓜. All Rights Reserved.</div>

    <!-- 动态线条背景代码 -->
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        let w = c.width = window.innerWidth;
        let h = c.height = window.innerHeight;
        let tick = 0;
        const TAU = Math.PI * 2;
        const vertices = [];

        const opts = {
            hexLength: 30,
            timeStep: 0.01,
            randomJig: 8,
            repaintColor: 'rgba(0,0,0,0.1)'
        };

        class Vertex {
            constructor(x, y) {
                this.len = Math.sqrt(x * x + y * y);
                this.rad = Math.acos(x / this.len) * (y > 0 ? 1 : -1) + 0.13;
                this.prevX = x;
                this.prevY = y;
            }

            step() {
                const prop = this.len / opts.hexLength / 10 - tick;
                const excitement = Math.sin(prop) ** 2;
                const nextLen = this.len + Math.sin(tick);
                const nextRad = this.rad + (excitement + prop) * 0.5;
                
                const hue = (nextRad / TAU * 360 + tick) % 360;
                const color = `hsl(${hue}, ${excitement * 100}%, ${20 + excitement * 50}%)`;

                ctx.strokeStyle = color;
                ctx.lineWidth = excitement + 0.2;
                ctx.beginPath();
                ctx.moveTo(this.prevX, this.prevY);
                
                this.prevX = nextLen * Math.cos(nextRad) + (Math.random() - 0.5) * opts.randomJig * (1 - excitement);
                this.prevY = nextLen * Math.sin(nextRad) + (Math.random() - 0.5) * opts.randomJig * (1 - excitement);
                
                ctx.lineTo(this.prevX, this.prevY);
                ctx.stroke();
            }

            static gen() {
                vertices.length = 0;
                const hexCos = Math.cos(TAU / 12) * opts.hexLength;
                const hexSin = Math.sin(TAU / 12) * opts.hexLength;
                let alternanceX = false;

                for (let x = 0; x < w; x += hexCos) {
                    alternanceX = !alternanceX;
                    let alternance = alternanceX;
                    for (let y = 0; y < h; y += hexSin + opts.hexLength) {
                        alternance = !alternance;
                        const vx = x - w / 2;
                        const vy = y + (alternance ? hexSin : 0) - h / 2;
                        vertices.push(new Vertex(vx, vy));
                    }
                }
            }
        }

        Vertex.gen();
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        function anim() {
            requestAnimationFrame(anim);
            tick += opts.timeStep;

            ctx.fillStyle = opts.repaintColor;
            ctx.fillRect(0, 0, w, h);

            ctx.save();
            ctx.translate(w / 2, h / 2);
            vertices.forEach(v => v.step());
            ctx.restore();
        }
        anim();

        window.addEventListener('resize', () => {
            w = c.width = window.innerWidth;
            h = c.height = window.innerHeight;
            Vertex.gen();
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
        });
    </script>

    <!-- 天气预报代码 -->
    <script>
        const API_HOST = 'devapi.qweather.com';
        const API_KEY = '05beb2ec0f884c25b8084d6749f37a36';

        const weatherCity = document.getElementById("weather-city");
        const weatherInfo = document.getElementById("weather-info");
        const weatherTemp = document.getElementById("weather-temp");
        const weatherIcon = document.getElementById("weather-icon");
        const citySelect = document.getElementById("city-select");

        async function fetchWeather(locationId) {
            try {
                const url = `https://${API_HOST}/v7/weather/now?location=${locationId}&key=${API_KEY}&lang=zh`;
                const res = await fetch(url);
                const data = await res.json();
                const now = data.now;
                const cityName = citySelect.options[citySelect.selectedIndex].text;
                weatherCity.textContent = `城市: ${cityName}`;
                weatherInfo.textContent = `天气: ${now.text}`;
                weatherTemp.textContent = `温度: ${now.temp}°C`;
                weatherIcon.src = `https://cdn.qweather.com/icons/${now.icon}.png`;
                weatherIcon.alt = now.text;
            } catch (err) {
                console.error(err);
                weatherCity.textContent = "城市: 获取失败";
                weatherInfo.textContent = "天气: 获取失败";
                weatherTemp.textContent = "温度: 获取失败";
                weatherIcon.src = "";
            }
        }

        fetchWeather(citySelect.value);
        citySelect.addEventListener("change", () => fetchWeather(citySelect.value));
    </script>

    <!-- 支持多指点击+滑动轨迹的随机爱心/五角星动画代码 -->
    <script>
        ! function(e, t, a) {
            let isDragging = false; // 标记是否处于滑动状态
            const shapeDensity = 8; // 滑动时形状密度（值越小越密集）

            function r() {
                // 同时处理爱心和五角星的动画
                for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? 
                (t.body.removeChild(s[e].el), s.splice(e, 1)) : 
                (s[e].y--, s[e].scale += .003, s[e].alpha -= .012,
                s[e].el.style.cssText = `left:${s[e].x}px;top:${s[e].y}px;opacity:${s[e].alpha};transform:scale(${s[e].scale},${s[e].scale}) ${s[e].type === 'heart' ? 'rotate(45deg)' : ''};color:${s[e].color};z-index:9999;pointer-events:none;`);
                requestAnimationFrame(r)
            }

            // 单指点击（PC/手机）
            function n() {
                t.addEventListener('click', function(e) {
                    if (!isDragging) o(e.clientX, e.clientY); // 非滑动时才触发点击
                });
            }

            // 多指点击（touchstart）
            function i() {
                t.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    isDragging = true;
                    // 多指同时按下，每个点生成一个形状
                    for (let touch of e.touches) {
                        o(touch.clientX, touch.clientY);
                    }
                }, { passive: false });
            }

            // 滑动轨迹（touchmove）- 沿滑动路径生成形状
            function d() {
                t.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    if (!isDragging) return;
                    // 滑动时遍历所有触控点，按密度生成形状
                    for (let touch of e.touches) {
                        // 控制形状密度，避免过于密集
                        const random = Math.floor(Math.random() * shapeDensity);
                        if (random === 0) o(touch.clientX, touch.clientY);
                    }
                }, { passive: false });
            }

            // 结束滑动（touchend/touchcancel）
            function l() {
                t.addEventListener('touchend', function() {
                    isDragging = false;
                });
                t.addEventListener('touchcancel', function() {
                    isDragging = false;
                });
            }

            // PC端鼠标滑动（mousemove）
            function m() {
                t.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    o(e.clientX, e.clientY); // 鼠标按下时生成第一个形状
                });
                t.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    // 鼠标滑动时按密度生成形状
                    const random = Math.floor(Math.random() * shapeDensity);
                    if (random === 0) o(e.clientX, e.clientY);
                });
                t.addEventListener('mouseup', function() {
                    isDragging = false;
                });
                t.addEventListener('mouseleave', function() {
                    isDragging = false;
                });
            }

            // 生成随机形状（爱心/五角星）
            function o(x, y) {
                const shapeType = Math.random() > 0.5 ? 'heart' : 'star'; // 50%概率
                var a = t.createElement("div");
                a.className = shapeType;
                const offset = shapeType === 'heart' ? 5 : 10; // 偏移量适配
                s.push({
                    el: a,
                    x: x - offset,
                    y: y - offset,
                    scale: 1,
                    alpha: 1,
                    color: c(),
                    type: shapeType
                });
                t.body.appendChild(a);
            }

            // 随机彩色
            function c() {
                return "rgb(" + ~~(230 + 25 * Math.random()) + "," + ~~(100 + 155 * Math.random()) + "," + ~~(100 + 155 * Math.random()) + ")"
            }

            var s = []; // 存储所有形状元素
            e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) {
                setTimeout(e, 1e3 / 60)
            };
            n(); // 单指点击
            i(); // 多指点击
            d(); // 手机滑动
            l(); // 结束滑动
            m(); // PC鼠标滑动
            r(); // 启动动画
        }(window, document);
    </script>
</body>
</html>
